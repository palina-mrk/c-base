backtrace(3) Руководство по обратной трассировке библиотечных функций (3)
НАЗВАНИЕ топ
 backtrace, backtrace_symbols, backtrace_symbols_fd — поддержка
самостоятельной отладки приложений
ТОПОВАЯ БИБЛИОТЕКА
 Стандартная библиотека C (libc, -lc)
РЕЗЮМЕ
       #include <execinfo.h>

       int backtrace(void *buffer[.size], int size);

       char **backtrace_symbols(void *const buffer[.size], int size);
       void backtrace_symbols_fd(void *const buffer[.size], int size, int fd);
ОПИСАНИЕ
       backtrace() возвращает трассировку для вызывающей программы в массиве, на который указывает buffer. Трассировка — это последовательность вызовов функций, которые в данный момент активны в программе. Каждый элемент в массиве, на который указывает buffer, имеет тип void * и является адресом возврата из соответствующего кадра стека. Аргумент size указывает максимальное количество адресов, которые могут быть сохранены в buffer. Если трассировка стека больше, чем размер, то возвращаются адреса, соответствующие размеру последних вызовов функций; чтобы получить полную трассировку стека, убедитесь, что buffer и size достаточно велики.

 При наличии набора адресов, возвращенных backtrace() в buffer, backtrace_symbols() преобразует набор адресов в массив строк, которые символьно описывают адреса. Аргумент size указывает количество адресов в buffer. Символьное представление каждого адреса состоит из имени функции (если его можно определить), шестнадцатеричного смещения внутри функции и фактического адреса возврата (в шестнадцатеричном формате). Адрес массива указателей на строки возвращается в качестве результата функции backtrace_symbols(). Этот массив аллоцирован через malloc(3) - выделяется функцией backtrace_symbols() и должен быть освобождён вызывающей стороной. (Строки, на которые указывает массив указателей, не нужно и не следует освобождать.)

 backtrace_symbols_fd() принимает те же аргументы buffer и size, что и backtrace_symbols(), но вместо возврата массива строк вызывающей стороне записывает строки по одной в файл с дескриптором fd. backtrace_symbols_fd() не вызывает malloc(3), поэтому может использоваться в ситуациях, когда последняя функция может завершиться ошибкой, но см. ПРИМЕЧАНИЯ.
ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
       backtrace() возвращает количество адресов, возвращённых в буфер, которое не превышает размер. Если возвращаемое значение меньше размера, то была сохранена полная трассировка; если оно равно размеру, то она могла быть усечена, и в этом случае адреса самых старых кадров стека не возвращаются.

 В случае успеха backtrace_symbols() возвращает указатель на массив, выделяемый с помощью malloc(3); в случае ошибки возвращается NULL.
АТРИБУТЫ 
 Объяснение терминов, используемых в этом разделе, см. в разделе атрибуты(7).
 ┌──────────────────────────────────────┬───────────────┬─────────┐
 │ Интерфейс │ Атрибут │ Значение │
 ├──────────────────────────────────────┼───────────────┼─────────┤
 │ backtrace(), backtrace_symbols(), │ Поточная безопасность │ MT-Safe │
 │ backtrace_symbols_fd() │ │ │
 └──────────────────────────────────────┴───────────────┴─────────┘
СТАНДАРТЫ GNU.
ТОПОВАЯ ИСТОРИЯ
 краткий обзор 2.1.
ПРИМЕЧАНИЯ
 Эти функции делают некоторые предположения о том, как адрес возврата функции
хранится в стеке. Обратите внимание на следующее:

 • Опущение указателей фрейма (что подразумевается при любом из gcc(1)'s
ненулевых уровней оптимизации) может привести к нарушению этих предположений.

 • У встроенных функций нет фреймов стека.

 • Оптимизация хвостовой рекурсии приводит к замене одного фрейма стека другим.

 • backtrace() и backtrace_symbols_fd() не вызывают malloc() явно, но они являются частью libgcc, которая загружается динамически при первом использовании. Динамическая загрузка обычно вызывает malloc(3). Если вам нужно, чтобы определенные вызовы этих двух функций не выделяли память (например, в обработчиках сигналов), вам нужно убедиться, что libgcc загружена заранее.

 Имена символов могут быть недоступны без использования специальных параметров компоновщика. Для систем, использующих компоновщик GNU, необходимо использовать параметр компоновщика -rdynamic. Обратите внимание, что имена «статических»  функций не отображаются и не будут доступны в трассировке.
ПРИМЕРЫ 
 Приведенная ниже программа демонстрирует использование backtrace() и 
 backtrace_symbols(). Следующий сеанс командной строки показывает, что мы 
 можем увидеть при запуске программы:

$ cc -rdynamic prog.c -o prog
 $ ./prog 3
 backtrace() returned 8 addresses
 ./prog(myfunc3+0x5c) [0x80487f0]
 ./prog [0x8048871]
 ./prog(myfunc+0x21) [0x8048894]
 ./prog(myfunc+0x1a) [0x804888d]
 ./prog(myfunc+0x1a) [0x804888d]
 ./prog(main+0x65) [0x80488fb]
 /lib/libc.so.6(__libc_start_main+0xdc) [0xb7e38f9c]
 ./prog [0x8048711]

Код программы:

 #include <execinfo.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>

 #define BT_BUF_SIZE 100

 void
 myfunc3(void)
 {
 int nptrs;
 void *buffer[BT_BUF_SIZE];
 char **strings;

 nptrs = backtrace(buffer, BT_BUF_SIZE);
 printf("backtrace() returned %d addresses\n", nptrs);


 /* Вызов backtrace_symbols_fd(буфер, nptrs, STDOUT_FILENO)
 выдаст примерно такой же вывод, как и следующий: */


 strings = backtrace_symbols(buffer, nptrs);
 if (strings == NULL) {
 perror("backtrace_symbols");
 exit(EXIT_FAILURE);
 }

 for (size_t j = 0; j < nptrs; j++)
 printf("%s\n", strings[j]);

 free(strings);
 }

 static void /* "static" означает, что символ не экспортируется... */
 myfunc2(void)
 {
 myfunc3();
 }

 void
 myfunc(int ncalls)
 {
 if (ncalls > 1)
 myfunc(ncalls - 1);
 else
 myfunc2();
 }

 int
 main(int argc, char *argv[])
 {

 if (argc != 2) {
 fprintf(stderr, "%s num-calls\n", argv[0]);
 exit(EXIT_FAILURE);
 }

 myfunc(atoi(argv[1]));
 exit(EXIT_SUCCESS);
 }

СМОТРИТЕ ТАКЖЕ вверху
       строка addr2(1), gcc(1), gdb(1), ld(1), длительное открытие (3), маллок(3)
КОЛОФОН сверху
 Эта страница является частью проекта man-pages (документация по пользовательскому интерфейсу ядра Linux и библиотеки C). Информацию о проекте можно найти по адресу ⟨https://www.kernel.org/doc/man-pages/⟩. Если у вас есть сообщение об ошибке для этой страницы руководства, см. ⟨https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING⟩.
 Эта страница была получена из архива man-pages-6.10.tar.gz, загруженного с
 ⟨https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/⟩ 2 февраля 2025 г. Если вы обнаружите какие-либо проблемы с отображением в этом HTML-файле
 Если вы считаете, что есть более качественная или актуальная версия страницы, или у вас есть исправления или улучшения информации в этом КОЛОФОНЕ (который не является частью оригинальной страницы руководства), отправьте электронное письмо по адресу
 man-pages@man7.org

Страницы руководства Linux 6.10 2024-07-23 backtrace(3)
