#include <stdio.h>
#include <stdlib.h>

enum encoding {WIN, KOI, ISO, ERR};
enum err {ARG_NUM, IN_FILE, OUT_FILE, ENC};

void to_utf(unsigned int sym, char* utf, int* len);
unsigned int to_uni(char c, enum encoding type);
void convert(FILE *f_in, FILE *f_out, enum encoding type);
enum encoding enc_type(char* str);
void print_error(enum err type, char* s);

int main(int argc, char** argv){
  FILE *f_in, *f_out;
  enum encoding tp;

  if(argc != 4){
    print_error(ARG_NUM, argv[0]);
    abort();
  }
  
  f_in = fopen(argv[1], "br");
  if(f_in == NULL){
    print_error(IN_FILE, argv[1]);
    abort();
  }
  f_out = fopen(argv[2], "bw");
  if(f_out == NULL){
    print_error(OUT_FILE, argv[2]);
    abort();
  } 
  tp = enc_type(argv[3]);
  if(tp == ERR){
    print_error(ENC, argv[3]);
    abort();
  }
  
  convert(f_in, f_out, tp);  

  fclose(f_in);  
  fclose(f_out);
  return 0;
}

unsigned int to_uni(char c, enum encoding type){
  static unsigned int win[] = {0x0402,0x0403,0x201A,0x0453,0x201E,0x2026,0x2020,0x2021,0x20AC,0x2030,0x0409,0x2039,0x040A,0x040C,0x040B,0x040F,0x0452,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,0x2122,0x0459,0x203A,0x045A,0x045C,0x045B,0x045F,0x00A0,0x040E,0x045E,0x0408,0x00A4,0x0490,0x00A6,0x00A7,0x0401,0x00A9,0x0404,0x00AB,0x00AC,0x00AD,0x00AE,0x0407,0x00B0,0x00B1,0x0406,0x0456,0x0491,0x00B5,0x00B6,0x00B7,0x0451,0x2116,0x0454,0x00BB,0x0458,0x0405,0x0455,0x0457,0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,0x041F,0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,0x0428,0x0429,0x042A,0x042B,0x042C,0x042D,0x042E,0x042F,0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,0x043F,0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,0x0448,0x0449,0x044A,0x044B,0x044C,0x044D,0x044E,0x044F};
  static unsigned int koi[] = {0x2500,0x2502,0x250C,0x2510,0x2514,0x2518,0x251C,0x2524,0x252C,0x2534,0x253C,0x2580,0x2584,0x2588,0x258C,0x2590,0x2591,0x2592,0x2593,0x2320,0x25A0,0x2219,0x221A,0x2248,0x2264,0x2265,0x00A0,0x2321,0x00B0,0x00B2,0x00B7,0x00F7,0x2550,0x2551,0x2552,0x0451,0x2553,0x2554,0x2555,0x2556,0x2557,0x2558,0x2559,0x255A,0x255B,0x255C,0x255D,0x255E,0x255F,0x2560,0x2561,0x0401,0x2562,0x2563,0x2564,0x2565,0x2566,0x2567,0x2568,0x2569,0x256A,0x256B,0x256C,0x00A9,0x044E,0x0430,0x0431,0x0446,0x0434,0x0435,0x0444,0x0433,0x0445,0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,0x043F,0x044F,0x0440,0x0441,0x0442,0x0443,0x0436,0x0432,0x044C,0x044B,0x0437,0x0448,0x044D,0x0449,0x0447,0x044A,0x042E,0x0410,0x0411,0x0426,0x0414,0x0415,0x0424,0x0413,0x0425,0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,0x041F,0x042F,0x0420,0x0421,0x0422,0x0423,0x0416,0x0412,0x042C,0x042B,0x0417,0x0428,0x042D,0x0429,0x0427,0x042A};
  static unsigned int iso[] = {0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,0x00A0,0x0401,0x0402,0x0403,0x0404,0x0405,0x0406,0x0407,0x0408,0x0409,0x040A,0x040B,0x040C,0x00AD,0x040E,0x040F,0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,0x041F,0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,0x0428,0x0429,0x042A,0x042B,0x042C,0x042D,0x042E,0x042F,0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,0x043F,0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,0x0448,0x0449,0x044A,0x044B,0x044C,0x044D,0x044E,0x044F,0x2116,0x0451,0x0452,0x0453,0x0454,0x0455,0x0456,0x0457,0x0458,0x0459,0x045A,0x045B,0x045C,0x00A7,0x045E,0x045F};

  if(c <= 0x80) return c;
  if (type == WIN) return win[c - 0x80];
  else if (type == KOI) return koi[c - 0x80];
  else if (type == ISO) return iso[c - 0x80];
  
  printf("Unrecognized encoding!");
  return 0; 
}

void to_utf(unsigned int sym, char* utf, int* len){
  if(sym <= 0x7F){
    *len = 1;
    // bin 0XXXXXX; 0'111'1111 = 0x7F
    utf[0] = (sym & 0x7f);
    return;
  } else if (sym <= 0x7FF){
    *len = 2;
    // 110XXXXX 10XXXXXX;
    // 110'00000 = 0xC0, 000'11111 = 0x1F
    utf[0] = (0xC0 | ((sym >> 6) & 0x1F));
    // 10'000000 = 0x80, 00'111111 = 0x3F
    utf[1] = (0x80 | (sym & 0x1F));
  } else if (sym <= 0xFFFF){
    *len = 3;
    // 1110XXXX 10XXXXXX 10XXXXXX
    // 1110'0000 = 0xE0, 0000'1111 = 0x0F
    utf[0] = (0xE0 | ((sym >> 12) & 0x0F));
    utf[1] = (0x80 | ((sym >> 6) & 0x1F));
    utf[2] = (0x80 | (sym & 0x1F));
  } else if (sym <= 0x10FFFF){
    *len = 4;
    // 11110XXXX 10XXXXXX 10XXXXXX 10XXXXXX
    // 11110'000 = 0xF0, 00000'111 = 0x07
    utf[0] = (0xF0 | ((sym >> 18) & 0x07));
    utf[1] = (0x80 | ((sym >> 12) & 0x1F));
    utf[2] = (0x80 | ((sym >> 6) & 0x1F));
    utf[2] = (0x80 | (sym & 0x1F));
  } else *len = 0;
  
  return;
}

void convert(FILE *f_in, FILE *f_out, enum encoding type){
  char sym;
  char buffer[4];
  int len, res, tmp;
  unsigned int uni;
  
  while((res = getc(f_in)) != EOF){
    sym = (char) res;
    uni = to_uni(sym, type);
    to_utf(uni, buffer, &len);
    
    tmp = -1;
    while(++tmp < len) putc(buffer[tmp], f_out);
  }  

  printf("The file is converted!\n");
  return;
}


void print_error(enum err type, char* s){
  if (type == ARG_NUM){
    printf("Input error: three arguments required:\n");
    printf("the 1-st it input file name, the 2-nd is output file name,\n");
    printf("and the 3-rd is the type of input encoding: win, koi or iso\n");
  } else if (type == IN_FILE){
    printf("Error: could not open file %s to read\n", s);
  } else if (type == OUT_FILE){
    printf("Error: could not open file %s to write\n", s);
  } else if (type == ENC) {
    printf("Error: %s is invalid encoding type\n", s);
    printf("koi, win or iso is required\n");
  } return;
}

enum encoding enc_type(char* str){
  if(str == NULL) return ERR;
  if(str[0] == '\0') return ERR;
  if(str[1] == '\0') return ERR;
  if(str[2] == '\0') return ERR;
  if(str[3] != '\0') return ERR;
  //koi
  if ( ((str[0] == 'k') || (str[0] == 'K'))
      && ((str[1] == 'o') || (str[1] == 'O'))
      && ((str[2] == 'i') || (str[2] == 'I')) ) return KOI; 
  //win
  if ( ((str[0] == 'w') || (str[0] == 'W'))
      && ((str[1] == 'i') || (str[1] == 'I'))
      && ((str[2] == 'n') || (str[2] == 'N')) ) return KOI; 
  //iso
  if ( ((str[0] == 'i') || (str[0] == 'I'))
      && ((str[1] == 's') || (str[1] == 'S'))
      && ((str[2] == 'o') || (str[2] == 'O')) ) return KOI; 
  return ERR; 
}
